@inherits LinkBase
@using Excubo.Blazor.Diagrams.Extensions
@using (var temporary_culture = new CultureSwapper())
{
    <g transform="scale(@Zoom)">
        @if (ControlPoints.Count == 3)
        {
            var width = Math.Abs(ControlPoints[2].X - ControlPoints[0].X);
            var height = Math.Abs(ControlPoints[2].Y - ControlPoints[0].Y);
            var down_first = (width < height);
            var first_point_x = (down_first) ? (ControlPoints[0].X) : (ControlPoints[1].X);
            var first_point_y = (down_first) ? (ControlPoints[1].Y) : (ControlPoints[0].Y);
            var second_point_x = (down_first) ? (ControlPoints[2].X) : (ControlPoints[1].X);
            var second_point_y = (down_first) ? (ControlPoints[1].Y) : (ControlPoints[2].Y);
            <path d="M @(ControlPoints[0].X) @(ControlPoints[0].Y)
                     L @(first_point_x) @(first_point_y)
                     L @(second_point_x) @(second_point_y)
                     L @(ControlPoints[2].X) @(ControlPoints[2].Y)"
                  stroke-width="3"
                  fill="none"
                  stroke="black"
                  @onmouseover="OnLinkOver"
                  @onmouseout="OnLinkOut" />
            @if (Selected)
            {
                foreach (var cp in ControlPoints.Skip(1).Take(1))
                {
                    <ellipse cx="@cp.X" cy="@cp.Y" rx="8" ry="8" fill="green" @onmouseover="cp.OnMouseOver" @onmouseout="@cp.OnMouseOut" />
                }
            }
        }
    </g>
}
@code {
    [Parameter]
    public bool CurveTopBottom { get; set; }
    private (double X, double Y) GetMiddlePoint()
    {
        return ((Source.X + Target.X) / 2, (Source.Y + Target.Y) / 2);
    }
    protected override void OnParametersSet()
    {
        if (ControlPointMethods == null)
        {
            ControlPointMethods = new List<Func<(double X, double Y)>>();
            ControlPointMethods.Add(GetMiddlePoint);
        }
        base.OnParametersSet();
    }
}